; test.si

test = module {
    square = proc (x, %_ = typeof(x)) { x * x }

    test_square = proc () {
        square(8, string) ; Hmmm... would probably make a new polymorph, but wouldn't be an error.

        square(8, f32)    ; This would be an error because square modded on f32 was already used
                          ; where x was an f32. But now, you're trying to use it where x is an i32,
                          ; so you have conflicting uses.
    }

    my_struct = struct { x, y, z }

    p = proc (x, y) {
        foozle = 0xDEADBEEF
        foo    = 123_000_000 + (0x4 + -42) * 3 / (foozle.field)
        zag    = foozle and *&foozle

        return
    }

    [[ barzle ]]
    [[ thinger ]]
    bar = 42

    baz = module {
        thinger = proc (a, b, ...) {
            thinger(abc = 123)
        }
    }
}

array = module {
    Array = struct {
        %data_type,
        data_ptr,
        used,
        capacity
    }

    make = proc (%T) {
        return Array(
            data_type = T,
            data_ptr  = mem_alloc(8 * sizeof(T)),
            used      = 0,
            capacity  = 8
        )
    }

    _grow = proc (a, %_ = a.data_type) {
        a.capacity *= 2
        a.data_ptr  = mem_realloc(a.data_ptr, a.capacity)
    }

    push = proc (a, item, %_ = a.data_type) {
        if a.used == a.capacity { _grow(a) }
        a.data_ptr[a.used] = item
        a.used += 1
    }

    item = proc (a, idx, %_ = a.data_type) {
        return a.data_ptr[idx]
    }

    free = proc (a) {
        mem_free(a.data_ptr)
    }
} ; module array

my_proc = proc () {
    my_array = array.make(f32)
        defer { array.free(my_array) }
    array.push(my_array, 1.23)
    one_two_three = array.item(my_array, 0)
}

heap_alloc = proc (%T) {
    return cast(pointer(T),
                heap_alloc_size(sizeof(T)))
}
my_data = heap_alloc(my_type)
sz = sizeof(pointer(char))
